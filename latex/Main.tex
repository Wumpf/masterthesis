\documentclass[thesis.tex]{subfiles}
\begin{document}

\chapter{Main}\label{chap:basics}

\section{Overview}

Many parts of our approach are based on several well-known techniques of which most have already been discussed in \autoref{chap:prevwork} and \autoref{chap:basics}.
Where necessary, details of the respective algorithms will be elaborated to address specifics implied by the overall technique.

Indirect light is only computed at 

First a novel scheme for evaluating and interpolating indirect light is introduced.
This is done by the \emph{Gather}-Pass, which resembles the first of the three steps our technique executes every frame.

Our approach is divided into three basic steps which are called \emph{Marking}, \emph{Lighting} and \emph{Apply}.
Additionally we need to maintain a voxelization of the scene to compute indirect shadows. 


Our technique performs steps in each frame:
\begin{easylist}[itemize]
# Cache Gathering
# Cache Lighting
# Cache Apply
\end{easylist}


\section{Realtime Light Cache Placement}

Inspired by the Lensing's LightSkin approach \cite{bib:LightskinPaper}, we wanted to compute indirect lighting only in specific locations instead of a per-pixel basis (as opposed to techniques like classic Reflective Shadow Maps or Voxel Cone Tracing).
Since the goal of this work is a fully dynamic solution that works without any pre-computations, it is necessary to place such caches at runtime.

Such an approach has several challenges in general:
Each cache has both be placed and provided with data in a temporal coherent way to avoid flickering.
Pixels need to have easy access to a certain number of caches to be able to interpolate them.
Note that this apply pass can have temporal coherence problems on its own, as the mapping from world positions to caches needs to be stable no matter how densely they are sampled, i.e. by how many pixels an object covers.

On the other hand, there are several intrinsic advantages which can be expected of a dynamic light cache placement:
The number of caches can be easily controlled by  ... screen space... distance ....
Low memory footprint, scalable

We evaluated several approaches before we came up with our final algorithm.
If you are interested you can read the summary of these attempts in \autoref{chap:abandoned}.

We ended up with a conceptually easy ....


\subsection{Adaptive Realtime (Ir-)Radiance Volumes}
Cache properties yield 6 dimensional space: Position (XYZ), Normal ($\theta$, $\omega$), Roughness (R)

Linear interpolation in 6D: 64 neighbors\\
Linear interpolation in 5D: 32 neighbors (not using roughness)

Can drastically reduce neighbor count:
\begin{easylist}
# Tetrahedral interpolation (instead of cube) of positions
# Interpolate 3 normals (thinks of a hexahedra or icosahedra)
\end{easylist}

Grid on position and sparse structure in normal/roughness? Think of preconvolved irradiance caches, but with 

\subsection{Memory representation}
Non-perfect Hashing. Striving for low collision count.
Still much better than full grid!

\section{Cache Lighting}
Array Cubemap only up to 2048 layer for nvidia

\section{Indirect Shadows}

\subsection{Scene Voxelization}

\subsection{Cone Casts on Filtered Reflective Shadow Maps}


\section{Cache Interpolation}



\section{Implementation Details}

\emph{As many as possible details should be delayed into this chapter. If it gets large or starts to mirror the main part, make it a chapter!}

This is the right place for describing how to use Compute, OpenGL etc. for achieving the rather abstract formulated goals of the sections before.

Deferred Renderer, 32bits per Layer RGB(A) srgb - Diffuse, RG 16snorm - Normals with angles, extra infos todo, R32F Depth Buffer (swapped near/far)\\
(This detail belongs more or less to Eva...)

\subfilebib % Makes bibliography available when compiling as subfile
\end{document}