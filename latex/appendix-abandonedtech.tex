\documentclass[thesis.tex]{subfiles}
\begin{document}

\section{Abandoned Cache Generation Approaches} \label{chap:abandoned}

%\section{Light Cache Generation}

Before we aligned all caches in camera centered, regular grids, where each cache has no information other than a position, we tried various other techniques. %to fetch various data and place caches dynamically, depending on the geometry.
The final regular grid technique has several disadvantages:
A cache has only a position and roughly half of the caches lie behind the geometry to be lit.
Since all pixels that will be influenced by a cache may be known up-front, it should be possible to feed more information to the caches.
Even better, placing caches directly \emph{on} geometry should result in more accurate lighting and could yield a local normal vector and material properties as well, similar to the pre-computed caches in LightSkin \cite{bib:LightskinPaper}.
As explained by the following examples we were not able to achieve such an intelligent placement of "complex" caches in real-time.

We started with experiments involving data extractions from the G-buffer.
Since we realized soon that it is extremely difficult to produce flicker-free movements when relying only on screen-space information without any world-space reference/anchor, we computed property averages of all pixels that lie in world-oriented grid cells.
The final cache would lie at the average position of all involved pixels.
The obtained normals and positions were most of the time smooth but faced temporal coherency problems at depth discontinuities.
Also this approach was rather slow since many threads tended to read/write the same data.

Another grid-based approach was to gather information during the voxelization pass in which normals, texture coordinates and thus material properties are available.
Using the depth buffer from the G-buffer stage, we were able to quickly decide which cells need to be filled with additional data.
Performance characteristics were a bit better as with the G-buffer approach since there were not as many writes into the same cache.
However, even when super sampling the voxel grid, the triangles that influence a cache can change rapidly from frame to frame.
This results in abruptly changing cache-normals.
For other material properties this problem is less dominant since they are read from textures where it is possible to sample the right mipmap to cover the cell.

A completely different way to obtain caches is by using all vertices as caches.
For triangles that cover too much screen-space, more vertices/caches can be generated by using tessellation.
Otherwise if for objects that are very far random vertices are discarded, using the vertex ID as random-seed.
The most difficult part however, is how the resulting caches can be interpolated.
Both tessellation and vertex discarding disrupts the original topology which is either way only doubtfully a good starting point for interpolation (due to cuts in meshes etc.).
Tessellation itself introduces many problems:
The vertices have no longer unique identifiers and the maximal tessellation level is not only slow but often not sufficient.
Therefore, it is not possible to guarantee a minimal cache density in screen-space this way.

Interpolation without any topology (grid or mesh) is a difficult problem that is addressed by several (irr)radiance caching papers, most notably by Ward's Irradiance Gradients \cite{bib:irradiancecachegradients}.
Adding more data to caches makes the interpolation more difficult as well:
Caches with position, normal and roughness have a six dimensional parameter space. 
For strict linear interpolation within a regular grid on all parameters, a pixel with individual parameters would need to access neighbors on all axis which yields 64 caches.
Since this is clearly too expensive, other ways of interpolation (and cache organization) are necessary like ignoring specific parameters for interpolation or interpolating within tetrahedrons instead of cubes.


\subfilebib % Makes bibliography available when compiling as subfile
\end{document}